Конструкторы представляют специальную функцию, которая имеет то же имя, что и класс, которая не возвращает никакого значения и которая позволяет инициализировать объект класса во время его создания и таким образом гарантировать, что поля класса будут иметь определенные значения.

Деструктор выполняет освобождение использованных объектом ресурсов и удаление нестатических переменных объекта.Деструктор автоматически вызывается, когда удаляется объект.

Функция определяет действия, которые выполняет программа. Функции позволяют выделить набор инструкций и назначить ему имя. А затем многократно  по присвоенному имени вызывать в различных частях программы. По сути функция - это именованный блок кода.

Тип void описывает выражение, не имеющее значения.

ОЗУ - оперативно-запоминающее устройство. Сюда загружается операционная система и все пользовательские программы. Устройство состоит из ячеек памяти, размерность которых совпадает c битностью операционной системы.

Условная конструкция if-else направляет ход программы по одному из возможных путей в зависимости от условия. Она проверяет истиность условия, и если оно истинно, выполняет блок инструкций. В простейшем виде конструкция if имеет следующую сокрощенную форму.

Указатели представляют собой объекты, значением которых служат  адреса других объектов (переменных, константов, указателей) или функций. Для определения указателя надо указать тип объекта, на который указывает указатель, и символ звездочки *.

Константы - это экземпляры типов данных, которые нельзя изменить. Константные методы представляют собой методы, которые не изменяют объекты. В константных методах можно вызывать константы.

// Что такое noexcept - ключевое слово noexcept ставится после метода который не должен выбрасывать исключение (не вызывать критичиские ошибки). В случае, если метод, помеченный noexcept, вызывает исключение, 

Применение функций вроде int() для выполнения инициализации объектов  класса  неэлегантно  и, ктому же, может приводить к ошибкам. Поскольку нигде нет жестких рамок, заставляющих программиста в обязательном порядке выполнять инициализацию, но в полне может и забыть об этом. Или выполнить инициализацию дважды (часто с катострофическими последствиями). Намного лучше обеспечить возможность объявить функцию-член, специальный и явно предназначенную для инициализации. Поскольку такие функции конструируют объекты класса, их принято называть конструкторами.

Переменная цикла for, условие окончание цикла и выражение, которое обновляетпеременную цикла, присутствуюут в явном виде в одном месте.
 
Но так как указатель хранит адрес, то мы можем по этому адресу получить хранящееся там значение, то есть значение переменной number. Для этого применяется операция * или операция разыменования ("inderection operator" / "dereferense operator"). Результатом этой операции всегда является объект, на который  указывает указатель. Применим данную операцию и получим значение переменной number:

#include <iostream>

int main()
{

   int number {25};
   int *pnumber {&number};
   std::cout << "Address = " << pnumber <<  std::endl;
   std::cout << "Value = " << *pnumber << std::endl;
}

Как и любые данные, код, который генерируется для тела функции, должен где-то распологатся в памяти, то есть он имеет адрес. Таким образом, мыможем настроить указатель нафункцию так же, как мы это делаем для объектов. Но по ряду причин, отчасти из-за особенностей машинных архетектур, от части по системным соображениям, с помощью указателя нелзя модифицировать код. Все что можно сделать с функцией - это вызвать ее или взять ее адрес. Указатель, который получает свое значение путем взятия адреса функции, может затем использоватся для ее вызавова. Например:

  void error(string)

Получение значения по указателю выполняется с помощью оператора *. Если у нас есть указатель ptr, то получить значение по этому указателю можно с помощью выражения *ptr
